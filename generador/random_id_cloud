import os
from dotenv import load_dotenv

load_dotenv()


import osmnx as ox
import networkx as nx
import random
from datetime import datetime
import time
import threading
import requests


# --- IMPORTACIONES PARA CLOUD SQL ---
from google.cloud.sql.connector import Connector, IPTypes

# URL de tu API local
API_URL = "http://192.168.1.44:8080"

# --- FUNCIONES DE BASE DE DATOS ---
def obtener_ids_desde_db():
    print("[DB] Consultando Cloud SQL por nuevos IDs...")
    
    # --- CHIVATO AÑADIDO ---
    print(f"DEBUG - Instancia: {os.getenv('INSTANCE_CONNECTION_NAME')}")
    print(f"DEBUG - Usuario: {os.getenv('DB_USER')}")
    # -----------------------
    
    try:
        connector = Connector()
        conn = connector.connect(
            os.getenv("INSTANCE_CONNECTION_NAME"), "pg8000",
            user=os.getenv("DB_USER"), password=os.getenv("DB_PASS"),
            db=os.getenv("DB_NAME"), ip_type=IPTypes.PUBLIC
        )
        cursor = conn.cursor()
        
        # CAMBIO APLICADO: Usamos 'id_victima' y 'id_agresor' según tus capturas
        cursor.execute("SELECT id_victima FROM victimas")
        victimas = [str(row[0]) for row in cursor.fetchall()] 
        
        cursor.execute("SELECT id_agresor FROM agresores")
        agresores = [str(row[0]) for row in cursor.fetchall()]
        
        conn.close()
        return victimas, agresores
    except Exception as e:
        print(f"[DB ERROR] Error al conectar o consultar la BBDD: {e}")
        return [], []


class SafetyMovementGenerator:
    def __init__(self, place_name="Valencia, Spain"):
        print(f"Descargando mapa de {place_name}...")
        self.graph = ox.graph_from_place(place_name, network_type='drive')
        self.nodes = list(self.graph.nodes())
        print(f"✓ Mapa cargado: {len(self.nodes)} nodos.")
        
        # Diccionario para llevar control de los hilos activos
        self.active_threads = {} 
        
    def send_to_api(self, data, role):
        """Diferencia el endpoint según el rol, pero no envía el rol en el JSON."""
        endpoint = "/victimas" if role == "VICTIMA" else "/agresores"
        data.pop('role', None) 
        
        try:
            requests.post(f"{API_URL}{endpoint}", json=data, timeout=5)
        except Exception as e:
            # Silenciado para no inundar la consola si la API falla momentáneamente
            pass 

    def user_thread(self, config):
        """Bucle de movimiento independiente para cada sujeto."""
        curr_node = random.choice(self.nodes)
        battery = random.uniform(85, 100)
        
        print(f"[THREAD START] Iniciado seguimiento para {config['role']} -> ID: {config['user_id']}")
        
        while True:
            try:
                target_node = random.choice(self.nodes)
                route = nx.shortest_path(self.graph, curr_node, target_node, weight='length')

                for node_id in route:
                    node_data = self.graph.nodes[node_id]
                    battery -= random.uniform(0.01, 0.05)
                    if battery <= 0: battery = 100 
                    
                    payload = {
                        "user_id": config['user_id'],
                        "coordinates": [node_data['y'], node_data['x']],
                        "kmh": config['kmh'],
                        "battery": round(battery, 1),
                        "timestamp": datetime.now().isoformat()
                    }

                    self.send_to_api(payload, config['role'])

                    curr_node = node_id
                    time.sleep(5)

            except Exception:
                time.sleep(1)
                continue

    def arrancar_hilo_si_no_existe(self, user_id, role):
        """Comprueba si el usuario ya tiene un hilo. Si no, lo crea."""
        if user_id not in self.active_threads:
            r = random.random()
            if r < 0.80: kmh = random.uniform(3, 6)   
            elif r < 0.95: kmh = random.uniform(30, 50) 
            else: kmh = random.uniform(12, 18) 

            config = {
                'user_id': user_id,
                'role': role,
                'kmh': round(kmh, 2)
            }
            
            t = threading.Thread(target=self.user_thread, args=(config,), daemon=True)
            t.start()
            self.active_threads[user_id] = t


# --- BUCLE PRINCIPAL (El "Vigía") ---
if __name__ == "__main__":
    generator = SafetyMovementGenerator()

    try:
        while True:
            # 1. Obtenemos los IDs reales de Cloud SQL
            v_reales, a_reales = obtener_ids_desde_db()
            
            # 2. Arrancamos los hilos para las víctimas
            for v_id in v_reales:
                generator.arrancar_hilo_si_no_existe(v_id, "VICTIMA")
                
            # 3. Arrancamos los hilos para los agresores
            for a_id in a_reales:
                generator.arrancar_hilo_si_no_existe(a_id, "AGRESOR")
            
            print(f"[INFO] Hilos activos actualmente: {len(generator.active_threads)}")
            
            # 4. Esperamos 60 segundos antes de volver a mirar la base de datos
            time.sleep(60) 
            
    except KeyboardInterrupt:
        print("\n[FIN] Simulación detenida manualmente.")